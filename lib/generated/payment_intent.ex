defmodule Stripe.PaymentIntent do
  use Stripe.Entity

  @moduledoc "A PaymentIntent guides you through the process of collecting a payment from your customer.\nWe recommend that you create exactly one PaymentIntent for each order or\ncustomer session in your system. You can reference the PaymentIntent later to\nsee the history of payment attempts for a particular session.\n\nA PaymentIntent transitions through\n[multiple statuses](https://stripe.com/docs/payments/intents#intent-statuses)\nthroughout its lifetime as it interfaces with Stripe.js to perform\nauthentication flows and ultimately creates at most one successful charge.\n\nRelated guide: [Payment Intents API](https://stripe.com/docs/payments/payment-intents)"
  (
    defstruct [
      :shipping,
      :id,
      :transfer_data,
      :statement_descriptor_suffix,
      :application_fee_amount,
      :amount_details,
      :transfer_group,
      :status,
      :payment_method_configuration_details,
      :cancellation_reason,
      :created,
      :currency,
      :canceled_at,
      :last_payment_error,
      :source,
      :object,
      :receipt_email,
      :client_secret,
      :application,
      :latest_charge,
      :statement_descriptor,
      :automatic_payment_methods,
      :invoice,
      :amount,
      :customer,
      :on_behalf_of,
      :next_action,
      :confirmation_method,
      :review,
      :amount_capturable,
      :payment_method_types,
      :description,
      :metadata,
      :amount_received,
      :payment_method_options,
      :capture_method,
      :processing,
      :livemode,
      :payment_method,
      :setup_future_usage
    ]

    @typedoc "The `payment_intent` type.\n\n  * `amount` Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).\n  * `amount_capturable` Amount that can be captured from this PaymentIntent.\n  * `amount_details` \n  * `amount_received` Amount that this PaymentIntent collects.\n  * `application` ID of the Connect application that created the PaymentIntent.\n  * `application_fee_amount` The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner's Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).\n  * `automatic_payment_methods` Settings to configure compatible payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods)\n  * `canceled_at` Populated when `status` is `canceled`, this is the time at which the PaymentIntent was canceled. Measured in seconds since the Unix epoch.\n  * `cancellation_reason` Reason for cancellation of this PaymentIntent, either user-provided (`duplicate`, `fraudulent`, `requested_by_customer`, or `abandoned`) or generated by Stripe internally (`failed_invoice`, `void_invoice`, or `automatic`).\n  * `capture_method` Controls when the funds will be captured from the customer's account.\n  * `client_secret` The client secret of this PaymentIntent. Used for client-side retrieval using a publishable key. \n\nThe client secret can be used to complete a payment from your frontend. It should not be stored, logged, or exposed to anyone other than the customer. Make sure that you have TLS enabled on any page that includes the client secret.\n\nRefer to our docs to [accept a payment](https://stripe.com/docs/payments/accept-a-payment?ui=elements) and learn about how `client_secret` should be handled.\n  * `confirmation_method` Describes whether we can confirm this PaymentIntent automatically, or if it requires customer action to confirm the payment.\n  * `created` Time at which the object was created. Measured in seconds since the Unix epoch.\n  * `currency` Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).\n  * `customer` ID of the Customer this PaymentIntent belongs to, if one exists.\n\nPayment methods attached to other Customers cannot be used with this PaymentIntent.\n\nIf present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent's payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.\n  * `description` An arbitrary string attached to the object. Often useful for displaying to users.\n  * `id` Unique identifier for the object.\n  * `invoice` ID of the invoice that created this PaymentIntent, if it exists.\n  * `last_payment_error` The payment error encountered in the previous PaymentIntent confirmation. It will be cleared if the PaymentIntent is later updated for any reason.\n  * `latest_charge` The latest charge created by this PaymentIntent.\n  * `livemode` Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.\n  * `metadata` Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Learn more about [storing information in metadata](https://stripe.com/docs/payments/payment-intents/creating-payment-intents#storing-information-in-metadata).\n  * `next_action` If present, this property tells you what actions you need to take in order for your customer to fulfill a payment using the provided source.\n  * `object` String representing the object's type. Objects of the same type share the same value.\n  * `on_behalf_of` The account (if any) for which the funds of the PaymentIntent are intended. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.\n  * `payment_method` ID of the payment method used in this PaymentIntent.\n  * `payment_method_configuration_details` Information about the payment method configuration used for this PaymentIntent.\n  * `payment_method_options` Payment-method-specific configuration for this PaymentIntent.\n  * `payment_method_types` The list of payment method types (e.g. card) that this PaymentIntent is allowed to use.\n  * `processing` If present, this property tells you about the processing state of the payment.\n  * `receipt_email` Email address that the receipt for the resulting payment will be sent to. If `receipt_email` is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).\n  * `review` ID of the review associated with this PaymentIntent, if any.\n  * `setup_future_usage` Indicates that you intend to make future payments with this PaymentIntent's payment method.\n\nProviding this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent's Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.\n\nWhen processing card payments, Stripe also uses `setup_future_usage` to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).\n  * `shipping` Shipping information for this PaymentIntent.\n  * `source` This is a legacy field that will be removed in the future. It is the ID of the Source object that is associated with this PaymentIntent, if one was supplied.\n  * `statement_descriptor` For card charges, use [statement_descriptor_suffix](https://stripe.com/docs/payments/account/statement-descriptors#dynamic). Otherwise, you can use this value as the complete description of a charge on your customers' statements. It must contain at least one letter and be 1–22 characters long.\n  * `statement_descriptor_suffix` Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.\n  * `status` Status of this PaymentIntent, one of `requires_payment_method`, `requires_confirmation`, `requires_action`, `processing`, `requires_capture`, `canceled`, or `succeeded`. Read more about each PaymentIntent [status](https://stripe.com/docs/payments/intents#intent-statuses).\n  * `transfer_data` The data that automatically creates a Transfer after the payment finalizes. Learn more about the [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).\n  * `transfer_group` A string that identifies the resulting payment as part of a group. Learn more about the [use case for connected accounts](https://stripe.com/docs/connect/separate-charges-and-transfers).\n"
    @type t :: %__MODULE__{
            amount: integer,
            amount_capturable: integer,
            amount_details: term,
            amount_received: integer,
            application: (binary | term) | nil,
            application_fee_amount: integer | nil,
            automatic_payment_methods: term | nil,
            canceled_at: integer | nil,
            cancellation_reason: binary | nil,
            capture_method: binary,
            client_secret: binary | nil,
            confirmation_method: binary,
            created: integer,
            currency: binary,
            customer: (binary | Stripe.Customer.t() | Stripe.DeletedCustomer.t()) | nil,
            description: binary | nil,
            id: binary,
            invoice: (binary | Stripe.Invoice.t()) | nil,
            last_payment_error: Stripe.ApiErrors.t() | nil,
            latest_charge: (binary | Stripe.Charge.t()) | nil,
            livemode: boolean,
            metadata: term,
            next_action: term | nil,
            object: binary,
            on_behalf_of: (binary | Stripe.Account.t()) | nil,
            payment_method: (binary | Stripe.PaymentMethod.t()) | nil,
            payment_method_configuration_details: term | nil,
            payment_method_options: term | nil,
            payment_method_types: term,
            processing: term | nil,
            receipt_email: binary | nil,
            review: (binary | Stripe.Review.t()) | nil,
            setup_future_usage: binary | nil,
            shipping: term | nil,
            source: (binary | Stripe.PaymentSource.t() | Stripe.DeletedPaymentSource.t()) | nil,
            statement_descriptor: binary | nil,
            statement_descriptor_suffix: binary | nil,
            status: binary,
            transfer_data: term | nil,
            transfer_group: binary | nil
          }
  )

  (
    @typedoc nil
    @type acss_debit :: %{
            optional(:mandate_options) => mandate_options,
            optional(:setup_future_usage) => :none | :off_session | :on_session,
            optional(:verification_method) => :automatic | :instant | :microdeposits
          }
  )

  (
    @typedoc "Shipping address."
    @type address :: %{
            optional(:city) => binary,
            optional(:country) => binary,
            optional(:line1) => binary,
            optional(:line2) => binary,
            optional(:postal_code) => binary,
            optional(:state) => binary
          }
  )

  (
    @typedoc nil
    @type affirm :: %{
            optional(:capture_method) => :manual,
            optional(:preferred_locale) => binary,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc nil
    @type afterpay_clearpay :: %{
            optional(:capture_method) => :manual,
            optional(:reference) => binary,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc nil
    @type alipay :: %{optional(:setup_future_usage) => :none | :off_session}
  )

  (
    @typedoc nil
    @type au_becs_debit :: %{optional(:setup_future_usage) => :none | :off_session | :on_session}
  )

  (
    @typedoc "When you enable this parameter, this PaymentIntent accepts payment methods that you enable in the Dashboard and that are compatible with this PaymentIntent's other parameters."
    @type automatic_payment_methods :: %{
            optional(:allow_redirects) => :always | :never,
            optional(:enabled) => boolean
          }
  )

  (
    @typedoc "If this is a `bacs_debit` PaymentMethod, this hash contains details about the Bacs Direct Debit bank account."
    @type bacs_debit :: %{optional(:account_number) => binary, optional(:sort_code) => binary}
  )

  (
    @typedoc nil
    @type bancontact :: %{
            optional(:preferred_language) => :de | :en | :fr | :nl,
            optional(:setup_future_usage) => :none | :off_session
          }
  )

  (
    @typedoc "Configuration for the bank transfer funding type, if the `funding_type` is set to `bank_transfer`."
    @type bank_transfer :: %{
            optional(:eu_bank_transfer) => eu_bank_transfer,
            optional(:requested_address_types) =>
              list(:aba | :iban | :sepa | :sort_code | :spei | :swift | :zengin),
            optional(:type) =>
              :eu_bank_transfer
              | :gb_bank_transfer
              | :jp_bank_transfer
              | :mx_bank_transfer
              | :us_bank_transfer
          }
  )

  (
    @typedoc "Billing information associated with the PaymentMethod that may be used or required by particular types of payment methods."
    @type billing_details :: %{
            optional(:address) => address | binary,
            optional(:email) => binary | binary,
            optional(:name) => binary | binary,
            optional(:phone) => binary | binary
          }
  )

  (
    @typedoc nil
    @type blik :: %{optional(:code) => binary}
  )

  (
    @typedoc nil
    @type boleto :: %{
            optional(:expires_after_days) => integer,
            optional(:setup_future_usage) => :none | :off_session | :on_session
          }
  )

  (
    @typedoc nil
    @type card :: %{
            optional(:capture_method) => :manual,
            optional(:cvc_token) => binary,
            optional(:installments) => installments,
            optional(:mandate_options) => mandate_options,
            optional(:moto) => boolean,
            optional(:network) =>
              :amex
              | :cartes_bancaires
              | :diners
              | :discover
              | :eftpos_au
              | :interac
              | :jcb
              | :mastercard
              | :unionpay
              | :unknown
              | :visa,
            optional(:request_extended_authorization) => :if_available | :never,
            optional(:request_incremental_authorization) => :if_available | :never,
            optional(:request_multicapture) => :if_available | :never,
            optional(:request_overcapture) => :if_available | :never,
            optional(:request_three_d_secure) => :any | :automatic | :challenge,
            optional(:setup_future_usage) => :none | :off_session | :on_session,
            optional(:statement_descriptor_suffix_kana) => binary | binary,
            optional(:statement_descriptor_suffix_kanji) => binary | binary,
            optional(:three_d_secure) => three_d_secure
          }
  )

  (
    @typedoc nil
    @type card_present :: %{
            optional(:request_extended_authorization) => boolean,
            optional(:request_incremental_authorization_support) => boolean
          }
  )

  (
    @typedoc "Cartes Bancaires-specific 3DS fields."
    @type cartes_bancaires :: %{
            optional(:cb_avalgo) => :"0" | :"1" | :"2" | :"3" | :"4" | :A,
            optional(:cb_exemption) => binary,
            optional(:cb_score) => integer
          }
  )

  (
    @typedoc nil
    @type cashapp :: %{
            optional(:capture_method) => :manual,
            optional(:setup_future_usage) => :none | :off_session | :on_session
          }
  )

  (
    @typedoc nil
    @type created :: %{
            optional(:gt) => integer,
            optional(:gte) => integer,
            optional(:lt) => integer,
            optional(:lte) => integer
          }
  )

  (
    @typedoc "This hash contains details about the customer acceptance of the Mandate."
    @type customer_acceptance :: %{
            optional(:accepted_at) => integer,
            optional(:offline) => map(),
            optional(:online) => online,
            optional(:type) => :offline | :online
          }
  )

  (
    @typedoc nil
    @type customer_balance :: %{
            optional(:bank_transfer) => bank_transfer,
            optional(:funding_type) => :bank_transfer,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc "Customer's date of birth"
    @type dob :: %{
            optional(:day) => integer,
            optional(:month) => integer,
            optional(:year) => integer
          }
  )

  (
    @typedoc "If this is an `eps` PaymentMethod, this hash contains details about the EPS payment method."
    @type eps :: %{
            optional(:bank) =>
              :arzte_und_apotheker_bank
              | :austrian_anadi_bank_ag
              | :bank_austria
              | :bankhaus_carl_spangler
              | :bankhaus_schelhammer_und_schattera_ag
              | :bawag_psk_ag
              | :bks_bank_ag
              | :brull_kallmus_bank_ag
              | :btv_vier_lander_bank
              | :capital_bank_grawe_gruppe_ag
              | :deutsche_bank_ag
              | :dolomitenbank
              | :easybank_ag
              | :erste_bank_und_sparkassen
              | :hypo_alpeadriabank_international_ag
              | :hypo_bank_burgenland_aktiengesellschaft
              | :hypo_noe_lb_fur_niederosterreich_u_wien
              | :hypo_oberosterreich_salzburg_steiermark
              | :hypo_tirol_bank_ag
              | :hypo_vorarlberg_bank_ag
              | :marchfelder_bank
              | :oberbank_ag
              | :raiffeisen_bankengruppe_osterreich
              | :schoellerbank_ag
              | :sparda_bank_wien
              | :volksbank_gruppe
              | :volkskreditbank_ag
              | :vr_bank_braunau
          }
  )

  (
    @typedoc "Configuration for the eu_bank_transfer funding type."
    @type eu_bank_transfer :: %{optional(:country) => binary}
  )

  (
    @typedoc "Additional fields for Financial Connections Session creation"
    @type financial_connections :: %{
            optional(:permissions) =>
              list(:balances | :ownership | :payment_method | :transactions),
            optional(:prefetch) => list(:balances | :transactions),
            optional(:return_url) => binary
          }
  )

  (
    @typedoc nil
    @type fpx :: %{optional(:setup_future_usage) => :none}
  )

  (
    @typedoc nil
    @type giropay :: %{optional(:setup_future_usage) => :none}
  )

  (
    @typedoc nil
    @type grabpay :: %{optional(:setup_future_usage) => :none}
  )

  (
    @typedoc nil
    @type ideal :: %{optional(:setup_future_usage) => :none | :off_session}
  )

  (
    @typedoc "Installment configuration for payments attempted on this PaymentIntent (Mexico Only).\n\nFor more information, see the [installments integration guide](https://stripe.com/docs/payments/installments)."
    @type installments :: %{optional(:enabled) => boolean, optional(:plan) => plan | binary}
  )

  (
    @typedoc nil
    @type klarna :: %{
            optional(:capture_method) => :manual,
            optional(:preferred_locale) =>
              :"cs-CZ"
              | :"da-DK"
              | :"de-AT"
              | :"de-CH"
              | :"de-DE"
              | :"el-GR"
              | :"en-AT"
              | :"en-AU"
              | :"en-BE"
              | :"en-CA"
              | :"en-CH"
              | :"en-CZ"
              | :"en-DE"
              | :"en-DK"
              | :"en-ES"
              | :"en-FI"
              | :"en-FR"
              | :"en-GB"
              | :"en-GR"
              | :"en-IE"
              | :"en-IT"
              | :"en-NL"
              | :"en-NO"
              | :"en-NZ"
              | :"en-PL"
              | :"en-PT"
              | :"en-SE"
              | :"en-US"
              | :"es-ES"
              | :"es-US"
              | :"fi-FI"
              | :"fr-BE"
              | :"fr-CA"
              | :"fr-CH"
              | :"fr-FR"
              | :"it-CH"
              | :"it-IT"
              | :"nb-NO"
              | :"nl-BE"
              | :"nl-NL"
              | :"pl-PL"
              | :"pt-PT"
              | :"sv-FI"
              | :"sv-SE",
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc nil
    @type konbini :: %{
            optional(:confirmation_number) => binary | binary,
            optional(:expires_after_days) => integer | binary,
            optional(:expires_at) => integer | binary,
            optional(:product_description) => binary | binary,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc nil
    @type link :: %{
            optional(:capture_method) => :manual,
            optional(:persistent_token) => binary,
            optional(:setup_future_usage) => :none | :off_session
          }
  )

  (
    @typedoc nil
    @type mandate_data :: %{optional(:customer_acceptance) => customer_acceptance}
  )

  (
    @typedoc "Additional fields for Mandate creation"
    @type mandate_options :: %{
            optional(:custom_mandate_url) => binary | binary,
            optional(:interval_description) => binary,
            optional(:payment_schedule) => :combined | :interval | :sporadic,
            optional(:transaction_type) => :business | :personal
          }
  )

  (
    @typedoc "Network specific 3DS fields. Network specific arguments require an\nexplicit card brand choice. The parameter `payment_method_options.card.network``\nmust be populated accordingly"
    @type network_options :: %{optional(:cartes_bancaires) => cartes_bancaires}
  )

  (
    @typedoc "Additional fields for network related functions"
    @type networks :: %{optional(:requested) => list(:ach | :us_domestic_wire)}
  )

  (
    @typedoc "If this is a Mandate accepted online, this hash contains details about the online acceptance."
    @type online :: %{optional(:ip_address) => binary, optional(:user_agent) => binary}
  )

  (
    @typedoc nil
    @type oxxo :: %{
            optional(:expires_after_days) => integer,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc "If this is a `p24` PaymentMethod, this hash contains details about the P24 payment method."
    @type p24 :: %{
            optional(:bank) =>
              :alior_bank
              | :bank_millennium
              | :bank_nowy_bfg_sa
              | :bank_pekao_sa
              | :banki_spbdzielcze
              | :blik
              | :bnp_paribas
              | :boz
              | :citi_handlowy
              | :credit_agricole
              | :envelobank
              | :etransfer_pocztowy24
              | :getin_bank
              | :ideabank
              | :ing
              | :inteligo
              | :mbank_mtransfer
              | :nest_przelew
              | :noble_pay
              | :pbac_z_ipko
              | :plus_bank
              | :santander_przelew24
              | :tmobile_usbugi_bankowe
              | :toyota_bank
              | :volkswagen_bank
          }
  )

  (
    @typedoc "If provided, this hash will be used to create a PaymentMethod. The new PaymentMethod will appear\nin the [payment_method](https://stripe.com/docs/api/payment_intents/object#payment_intent_object-payment_method)\nproperty on the PaymentIntent."
    @type payment_method_data :: %{
            optional(:pix) => map(),
            optional(:fpx) => fpx,
            optional(:affirm) => map(),
            optional(:acss_debit) => acss_debit,
            optional(:bacs_debit) => bacs_debit,
            optional(:alipay) => map(),
            optional(:giropay) => map(),
            optional(:ideal) => ideal,
            optional(:revolut_pay) => map(),
            optional(:radar_options) => radar_options,
            optional(:metadata) => %{optional(binary) => binary},
            optional(:link) => map(),
            optional(:promptpay) => map(),
            optional(:cashapp) => map(),
            optional(:oxxo) => map(),
            optional(:interac_present) => map(),
            optional(:us_bank_account) => us_bank_account,
            optional(:zip) => map(),
            optional(:paypal) => map(),
            optional(:boleto) => boleto,
            optional(:konbini) => map(),
            optional(:billing_details) => billing_details,
            optional(:blik) => map(),
            optional(:wechat_pay) => map(),
            optional(:sofort) => sofort,
            optional(:p24) => p24,
            optional(:afterpay_clearpay) => map(),
            optional(:type) =>
              :acss_debit
              | :affirm
              | :afterpay_clearpay
              | :alipay
              | :au_becs_debit
              | :bacs_debit
              | :bancontact
              | :blik
              | :boleto
              | :cashapp
              | :customer_balance
              | :eps
              | :fpx
              | :giropay
              | :grabpay
              | :ideal
              | :klarna
              | :konbini
              | :link
              | :oxxo
              | :p24
              | :paynow
              | :paypal
              | :pix
              | :promptpay
              | :revolut_pay
              | :sepa_debit
              | :sofort
              | :us_bank_account
              | :wechat_pay
              | :zip,
            optional(:grabpay) => map(),
            optional(:bancontact) => map(),
            optional(:au_becs_debit) => au_becs_debit,
            optional(:customer_balance) => map(),
            optional(:sepa_debit) => sepa_debit,
            optional(:klarna) => klarna,
            optional(:paynow) => map(),
            optional(:eps) => eps
          }
  )

  (
    @typedoc "Payment method-specific configuration for this PaymentIntent."
    @type payment_method_options :: %{
            optional(:pix) => pix | binary,
            optional(:fpx) => fpx | binary,
            optional(:affirm) => affirm | binary,
            optional(:acss_debit) => acss_debit | binary,
            optional(:bacs_debit) => bacs_debit | binary,
            optional(:alipay) => alipay | binary,
            optional(:giropay) => giropay | binary,
            optional(:ideal) => ideal | binary,
            optional(:revolut_pay) => revolut_pay | binary,
            optional(:card) => card | binary,
            optional(:link) => link | binary,
            optional(:promptpay) => promptpay | binary,
            optional(:cashapp) => cashapp | binary,
            optional(:oxxo) => oxxo | binary,
            optional(:interac_present) => map() | binary,
            optional(:us_bank_account) => us_bank_account | binary,
            optional(:zip) => zip | binary,
            optional(:paypal) => paypal | binary,
            optional(:boleto) => boleto | binary,
            optional(:konbini) => konbini | binary,
            optional(:blik) => blik | binary,
            optional(:wechat_pay) => wechat_pay | binary,
            optional(:sofort) => sofort | binary,
            optional(:p24) => p24 | binary,
            optional(:afterpay_clearpay) => afterpay_clearpay | binary,
            optional(:grabpay) => grabpay | binary,
            optional(:bancontact) => bancontact | binary,
            optional(:au_becs_debit) => au_becs_debit | binary,
            optional(:customer_balance) => customer_balance | binary,
            optional(:card_present) => card_present | binary,
            optional(:sepa_debit) => sepa_debit | binary,
            optional(:klarna) => klarna | binary,
            optional(:paynow) => paynow | binary,
            optional(:eps) => eps | binary
          }
  )

  (
    @typedoc nil
    @type paynow :: %{optional(:setup_future_usage) => :none}
  )

  (
    @typedoc nil
    @type paypal :: %{
            optional(:capture_method) => :manual,
            optional(:preferred_locale) =>
              :"cs-CZ"
              | :"da-DK"
              | :"de-AT"
              | :"de-DE"
              | :"de-LU"
              | :"el-GR"
              | :"en-GB"
              | :"en-US"
              | :"es-ES"
              | :"fi-FI"
              | :"fr-BE"
              | :"fr-FR"
              | :"fr-LU"
              | :"hu-HU"
              | :"it-IT"
              | :"nl-BE"
              | :"nl-NL"
              | :"pl-PL"
              | :"pt-PT"
              | :"sk-SK"
              | :"sv-SE",
            optional(:reference) => binary,
            optional(:risk_correlation_id) => binary,
            optional(:setup_future_usage) => :none | :off_session
          }
  )

  (
    @typedoc nil
    @type pix :: %{
            optional(:expires_after_seconds) => integer,
            optional(:expires_at) => integer,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc nil
    @type plan :: %{
            optional(:count) => integer,
            optional(:interval) => :month,
            optional(:type) => :fixed_count
          }
  )

  (
    @typedoc nil
    @type promptpay :: %{optional(:setup_future_usage) => :none}
  )

  (
    @typedoc "Options to configure Radar. Learn more about [Radar Sessions](https://stripe.com/docs/radar/radar-session)."
    @type radar_options :: %{optional(:session) => binary}
  )

  (
    @typedoc nil
    @type revolut_pay :: %{optional(:setup_future_usage) => :none | :off_session}
  )

  (
    @typedoc nil
    @type sepa_debit :: %{
            optional(:mandate_options) => map(),
            optional(:setup_future_usage) => :none | :off_session | :on_session
          }
  )

  (
    @typedoc "Shipping information for this PaymentIntent."
    @type shipping :: %{
            optional(:address) => address,
            optional(:carrier) => binary,
            optional(:name) => binary,
            optional(:phone) => binary,
            optional(:tracking_number) => binary
          }
  )

  (
    @typedoc nil
    @type sofort :: %{
            optional(:preferred_language) => :de | :en | :es | :fr | :it | :nl | :pl,
            optional(:setup_future_usage) => :none | :off_session
          }
  )

  (
    @typedoc "If 3D Secure authentication was performed with a third-party provider,\nthe authentication details to use for this payment."
    @type three_d_secure :: %{
            optional(:ares_trans_status) => :A | :C | :I | :N | :R | :U | :Y,
            optional(:cryptogram) => binary,
            optional(:electronic_commerce_indicator) => :"01" | :"02" | :"05" | :"06" | :"07",
            optional(:exemption_indicator) => :low_risk | :none,
            optional(:network_options) => network_options,
            optional(:requestor_challenge_indicator) => binary,
            optional(:transaction_id) => binary,
            optional(:version) => :"1.0.2" | :"2.1.0" | :"2.2.0"
          }
  )

  (
    @typedoc "The parameters that you can use to automatically create a Transfer.\nLearn more about the [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts)."
    @type transfer_data :: %{optional(:amount) => integer, optional(:destination) => binary}
  )

  (
    @typedoc "If this is an `us_bank_account` PaymentMethod, this hash contains details about the US bank account payment method."
    @type us_bank_account :: %{
            optional(:account_holder_type) => :company | :individual,
            optional(:account_number) => binary,
            optional(:account_type) => :checking | :savings,
            optional(:financial_connections_account) => binary,
            optional(:routing_number) => binary
          }
  )

  (
    @typedoc nil
    @type wechat_pay :: %{
            optional(:app_id) => binary,
            optional(:client) => :android | :ios | :web,
            optional(:setup_future_usage) => :none
          }
  )

  (
    @typedoc nil
    @type zip :: %{optional(:setup_future_usage) => :none}
  )

  (
    nil

    @doc "<p>Returns a list of PaymentIntents.</p>\n\n#### Details\n\n * Method: `get`\n * Path: `/v1/payment_intents`\n"
    (
      @spec list(
              params :: %{
                optional(:created) => created | integer,
                optional(:customer) => binary,
                optional(:ending_before) => binary,
                optional(:expand) => list(binary),
                optional(:limit) => integer,
                optional(:starting_after) => binary
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.List.t(Stripe.PaymentIntent.t())}
              | {:error, Stripe.ApiErrors.t()}
              | {:error, term()}
      def list(params \\ %{}, opts \\ []) do
        path = Stripe.OpenApi.Path.replace_path_params("/v1/payment_intents", [], [])

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:get)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Retrieves the details of a PaymentIntent that has previously been created. </p>\n\n<p>You can retrieve a PaymentIntent client-side using a publishable key when the <code>client_secret</code> is in the query string. </p>\n\n<p>If you retrieve a PaymentIntent with a publishable key, it only returns a subset of properties. Refer to the <a href=\"#payment_intent_object\">payment intent</a> object reference for more details.</p>\n\n#### Details\n\n * Method: `get`\n * Path: `/v1/payment_intents/{intent}`\n"
    (
      @spec retrieve(
              intent :: binary(),
              params :: %{optional(:client_secret) => binary, optional(:expand) => list(binary)},
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def retrieve(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:get)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Search for PaymentIntents you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>.\nDon’t use search in read-after-write flows where strict consistency is necessary. Under normal operating\nconditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up\nto an hour behind during outages. Search functionality is not available to merchants in India.</p>\n\n#### Details\n\n * Method: `get`\n * Path: `/v1/payment_intents/search`\n"
    (
      @spec search(
              params :: %{
                optional(:expand) => list(binary),
                optional(:limit) => integer,
                optional(:page) => binary,
                optional(:query) => binary
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.SearchResult.t(Stripe.PaymentIntent.t())}
              | {:error, Stripe.ApiErrors.t()}
              | {:error, term()}
      def search(params \\ %{}, opts \\ []) do
        path = Stripe.OpenApi.Path.replace_path_params("/v1/payment_intents/search", [], [])

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:get)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Creates a PaymentIntent object.</p>\n\n<p>After the PaymentIntent is created, attach a payment method and <a href=\"/docs/api/payment_intents/confirm\">confirm</a>\nto continue the payment. Learn more about <a href=\"/docs/payments/payment-intents\">the available payment flows\nwith the Payment Intents API</a>.</p>\n\n<p>When you use <code>confirm=true</code> during creation, it’s equivalent to creating\nand confirming the PaymentIntent in the same call. You can use any parameters\navailable in the <a href=\"/docs/api/payment_intents/confirm\">confirm API</a> when you supply\n<code>confirm=true</code>.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents`\n"
    (
      @spec create(
              params :: %{
                optional(:amount) => integer,
                optional(:application_fee_amount) => integer,
                optional(:automatic_payment_methods) => automatic_payment_methods,
                optional(:capture_method) => :automatic | :automatic_async | :manual,
                optional(:confirm) => boolean,
                optional(:confirmation_method) => :automatic | :manual,
                optional(:currency) => binary,
                optional(:customer) => binary,
                optional(:description) => binary,
                optional(:error_on_requires_action) => boolean,
                optional(:expand) => list(binary),
                optional(:mandate) => binary,
                optional(:mandate_data) => mandate_data | binary,
                optional(:metadata) => %{optional(binary) => binary},
                optional(:off_session) => boolean | :one_off | :recurring,
                optional(:on_behalf_of) => binary,
                optional(:payment_method) => binary,
                optional(:payment_method_configuration) => binary,
                optional(:payment_method_data) => payment_method_data,
                optional(:payment_method_options) => payment_method_options,
                optional(:payment_method_types) => list(binary),
                optional(:radar_options) => radar_options,
                optional(:receipt_email) => binary,
                optional(:return_url) => binary,
                optional(:setup_future_usage) => :off_session | :on_session,
                optional(:shipping) => shipping,
                optional(:statement_descriptor) => binary,
                optional(:statement_descriptor_suffix) => binary,
                optional(:transfer_data) => transfer_data,
                optional(:transfer_group) => binary,
                optional(:use_stripe_sdk) => boolean
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def create(params \\ %{}, opts \\ []) do
        path = Stripe.OpenApi.Path.replace_path_params("/v1/payment_intents", [], [])

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Updates properties on a PaymentIntent object without confirming.</p>\n\n<p>Depending on which properties you update, you might need to confirm the\nPaymentIntent again. For example, updating the <code>payment_method</code>\nalways requires you to confirm the PaymentIntent again. If you prefer to\nupdate and confirm at the same time, we recommend updating properties through\nthe <a href=\"/docs/api/payment_intents/confirm\">confirm API</a> instead.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}`\n"
    (
      @spec update(
              intent :: binary(),
              params :: %{
                optional(:amount) => integer,
                optional(:application_fee_amount) => integer | binary,
                optional(:capture_method) => :automatic | :automatic_async | :manual,
                optional(:currency) => binary,
                optional(:customer) => binary,
                optional(:description) => binary,
                optional(:expand) => list(binary),
                optional(:metadata) => %{optional(binary) => binary} | binary,
                optional(:payment_method) => binary,
                optional(:payment_method_configuration) => binary,
                optional(:payment_method_data) => payment_method_data,
                optional(:payment_method_options) => payment_method_options,
                optional(:payment_method_types) => list(binary),
                optional(:receipt_email) => binary | binary,
                optional(:setup_future_usage) => :off_session | :on_session,
                optional(:shipping) => shipping | binary,
                optional(:statement_descriptor) => binary,
                optional(:statement_descriptor_suffix) => binary,
                optional(:transfer_data) => transfer_data,
                optional(:transfer_group) => binary
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def update(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Manually reconcile the remaining amount for a <code>customer_balance</code> PaymentIntent.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}/apply_customer_balance`\n"
    (
      @spec apply_customer_balance(
              intent :: binary(),
              params :: %{
                optional(:amount) => integer,
                optional(:currency) => binary,
                optional(:expand) => list(binary)
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def apply_customer_balance(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}/apply_customer_balance",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>You can cancel a PaymentIntent object when it’s in one of these statuses: <code>requires_payment_method</code>, <code>requires_capture</code>, <code>requires_confirmation</code>, <code>requires_action</code> or, <a href=\"/docs/payments/intents\">in rare cases</a>, <code>processing</code>. </p>\n\n<p>After it’s canceled, no additional charges are made by the PaymentIntent and any operations on the PaymentIntent fail with an error. For PaymentIntents with a <code>status</code> of <code>requires_capture</code>, the remaining <code>amount_capturable</code> is automatically refunded. </p>\n\n<p>You can’t cancel the PaymentIntent for a Checkout Session. <a href=\"/docs/api/checkout/sessions/expire\">Expire the Checkout Session</a> instead.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}/cancel`\n"
    (
      @spec cancel(
              intent :: binary(),
              params :: %{
                optional(:cancellation_reason) =>
                  :abandoned | :duplicate | :fraudulent | :requested_by_customer,
                optional(:expand) => list(binary)
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def cancel(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}/cancel",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Capture the funds of an existing uncaptured PaymentIntent when its status is <code>requires_capture</code>.</p>\n\n<p>Uncaptured PaymentIntents are cancelled a set number of days (7 by default) after their creation.</p>\n\n<p>Learn more about <a href=\"/docs/payments/capture-later\">separate authorization and capture</a>.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}/capture`\n"
    (
      @spec capture(
              intent :: binary(),
              params :: %{
                optional(:amount_to_capture) => integer,
                optional(:application_fee_amount) => integer,
                optional(:expand) => list(binary),
                optional(:final_capture) => boolean,
                optional(:metadata) => %{optional(binary) => binary} | binary,
                optional(:statement_descriptor) => binary,
                optional(:statement_descriptor_suffix) => binary,
                optional(:transfer_data) => transfer_data
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def capture(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}/capture",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Confirm that your customer intends to pay with current or provided\npayment method. Upon confirmation, the PaymentIntent will attempt to initiate\na payment.\nIf the selected payment method requires additional authentication steps, the\nPaymentIntent will transition to the <code>requires_action</code> status and\nsuggest additional actions via <code>next_action</code>. If payment fails,\nthe PaymentIntent transitions to the <code>requires_payment_method</code> status or the\n<code>canceled</code> status if the confirmation limit is reached. If\npayment succeeds, the PaymentIntent will transition to the <code>succeeded</code>\nstatus (or <code>requires_capture</code>, if <code>capture_method</code> is set to <code>manual</code>).\nIf the <code>confirmation_method</code> is <code>automatic</code>, payment may be attempted\nusing our <a href=\"/docs/stripe-js/reference#stripe-handle-card-payment\">client SDKs</a>\nand the PaymentIntent’s <a href=\"#payment_intent_object-client_secret\">client_secret</a>.\nAfter <code>next_action</code>s are handled by the client, no additional\nconfirmation is required to complete the payment.\nIf the <code>confirmation_method</code> is <code>manual</code>, all payment attempts must be\ninitiated using a secret key.\nIf any actions are required for the payment, the PaymentIntent will\nreturn to the <code>requires_confirmation</code> state\nafter those actions are completed. Your server needs to then\nexplicitly re-confirm the PaymentIntent to initiate the next payment\nattempt. Read the <a href=\"/docs/payments/payment-intents/web-manual\">expanded documentation</a>\nto learn more about manual confirmation.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}/confirm`\n"
    (
      @spec confirm(
              intent :: binary(),
              params :: %{
                optional(:capture_method) => :automatic | :automatic_async | :manual,
                optional(:error_on_requires_action) => boolean,
                optional(:expand) => list(binary),
                optional(:mandate) => binary,
                optional(:mandate_data) => mandate_data | binary | mandate_data,
                optional(:off_session) => boolean | :one_off | :recurring,
                optional(:payment_method) => binary,
                optional(:payment_method_data) => payment_method_data,
                optional(:payment_method_options) => payment_method_options,
                optional(:radar_options) => radar_options,
                optional(:receipt_email) => binary | binary,
                optional(:return_url) => binary,
                optional(:setup_future_usage) => :off_session | :on_session,
                optional(:shipping) => shipping | binary,
                optional(:use_stripe_sdk) => boolean
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def confirm(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}/confirm",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Perform an incremental authorization on an eligible\n<a href=\"/docs/api/payment_intents/object\">PaymentIntent</a>. To be eligible, the\nPaymentIntent’s status must be <code>requires_capture</code> and\n<a href=\"/docs/api/charges/object#charge_object-payment_method_details-card_present-incremental_authorization_supported\">incremental_authorization_supported</a>\nmust be <code>true</code>.</p>\n\n<p>Incremental authorizations attempt to increase the authorized amount on\nyour customer’s card to the new, higher <code>amount</code> provided. Similar to the\ninitial authorization, incremental authorizations can be declined. A\nsingle PaymentIntent can call this endpoint multiple times to further\nincrease the authorized amount.</p>\n\n<p>If the incremental authorization succeeds, the PaymentIntent object\nreturns with the updated\n<a href=\"/docs/api/payment_intents/object#payment_intent_object-amount\">amount</a>.\nIf the incremental authorization fails, a\n<a href=\"/docs/error-codes#card-declined\">card_declined</a> error returns, and no other\nfields on the PaymentIntent or Charge update. The PaymentIntent\nobject remains capturable for the previously authorized amount.</p>\n\n<p>Each PaymentIntent can have a maximum of 10 incremental authorization attempts, including declines.\nAfter it’s captured, a PaymentIntent can no longer be incremented.</p>\n\n<p>Learn more about <a href=\"/docs/terminal/features/incremental-authorizations\">incremental authorizations</a>.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}/increment_authorization`\n"
    (
      @spec increment_authorization(
              intent :: binary(),
              params :: %{
                optional(:amount) => integer,
                optional(:application_fee_amount) => integer,
                optional(:description) => binary,
                optional(:expand) => list(binary),
                optional(:metadata) => %{optional(binary) => binary},
                optional(:statement_descriptor) => binary,
                optional(:transfer_data) => transfer_data
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def increment_authorization(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}/increment_authorization",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )

  (
    nil

    @doc "<p>Verifies microdeposits on a PaymentIntent object.</p>\n\n#### Details\n\n * Method: `post`\n * Path: `/v1/payment_intents/{intent}/verify_microdeposits`\n"
    (
      @spec verify_microdeposits(
              intent :: binary(),
              params :: %{
                optional(:amounts) => list(integer),
                optional(:descriptor_code) => binary,
                optional(:expand) => list(binary)
              },
              opts :: Keyword.t()
            ) ::
              {:ok, Stripe.PaymentIntent.t()} | {:error, Stripe.ApiErrors.t()} | {:error, term()}
      def verify_microdeposits(intent, params \\ %{}, opts \\ []) do
        path =
          Stripe.OpenApi.Path.replace_path_params(
            "/v1/payment_intents/{intent}/verify_microdeposits",
            [
              %OpenApiGen.Blueprint.Parameter{
                in: "path",
                name: "intent",
                required: true,
                schema: %OpenApiGen.Blueprint.Parameter.Schema{
                  name: "intent",
                  title: nil,
                  type: "string",
                  items: [],
                  properties: [],
                  any_of: []
                }
              }
            ],
            [intent]
          )

        Stripe.Request.new_request(opts)
        |> Stripe.Request.put_endpoint(path)
        |> Stripe.Request.put_params(params)
        |> Stripe.Request.put_method(:post)
        |> Stripe.Request.make_request()
      end
    )
  )
end
